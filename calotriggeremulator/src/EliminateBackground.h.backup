#ifndef ELIMINATEBACKGROUND_H
#define ELIMINATEBACKGROUND_H

#include <fun4all/SubsysReco.h>
#include <map>
#include <string>
#include <vector>
#include <ostream>
#include <iostream>
#include "TVector3.h"
#include "TrashInfov1.h"
#include "TrashInfo.h"
// Forward declarations
class PHCompositeNode;
class TH2;
class TowerInfoContainer;
class TH2F;
class TVector2;
class TVector3;
class TProfile;
class Fun4AllHistoManager;
class RawTowerGeomContainer;
class TrashInfo;
struct TowerStat
{
  unsigned int key = 0;
  float energy = 0.;
  float eta = -99.;
  float phi = 0.;
  int ieta = 0;
  int iphi = 0;
};

struct ClusterStat
{
  int emcal_hcal = 1;
  float energy = 0;
  float max_energy = 0;
  float emcal_energy = 0;
  int r1 = 0;
  int r2 = 0;
  float eta = 0;
  float phi = 0;
  float spread = 0.;
  std::vector<TowerStat> towers{};

  ClusterStat(std::vector<TowerStat> ts = {})
  : towers{ts}
  {
    calculate();
  }

  void print()
  {
    std::cout << " -- Cluster Stat -- " <<std::endl;
    std::cout << "  energy    : " << energy <<std::endl;
    std::cout << "  max_energy: " << max_energy <<std::endl;
    std::cout << "  em energy : " << emcal_energy << std::endl;
    std::cout << "  r1        : " << r1 << std::endl;
    std::cout << "  r2        : " << r2 << std::endl;
    std::cout << "  eta        : " << eta << std::endl;
    std::cout << "  phi        : " << phi << std::endl;
    std::cout << "  spread        : " << spread << std::endl;
  }

  // assignment operator modifies object, therefore non-const
  ClusterStat& operator=(const ClusterStat& a)
  {
    emcal_hcal = a.emcal_hcal;
    energy = a.energy;
    max_energy = a.max_energy;
    emcal_energy = a.emcal_energy;
    r1 = a.r1;
    r2 = a.r2;
    eta = a.eta;    
    phi = a.phi;    
    spread = a.spread;
    towers = a.towers;
    
    return *this;
  }

    void calculate()
  {
    std::vector<int> unique_phi;
    std::vector<int> unique_eta;
    TVector3 vCluster(0,0,0);
    max_energy = 0;
    for (auto &tower : towers)
      {
	if (tower.energy > max_energy) max_energy = tower.energy;
	TVector3 v3;
	v3.SetPtEtaPhi(tower.energy, tower.eta, tower.phi);
	vCluster += v3;
	if (std::find(unique_phi.begin(), unique_phi.end(), tower.iphi) == unique_phi.end()) unique_phi.push_back(tower.iphi);
	if (std::find(unique_eta.begin(), unique_eta.end(), tower.ieta) == unique_eta.end()) unique_eta.push_back(tower.ieta);
      }

    r1 = (int) unique_eta.size();
    r2 = (int) unique_phi.size();

    energy = vCluster.Pt();
    phi = vCluster.Phi();
    eta = vCluster.Eta();

    TVector2 plane(vCluster.Eta(), vCluster.Phi());
    spread = 0;

    for (auto &tower : towers)
      {
	TVector2 v(tower.eta, tower.phi);
	v -= plane;
	spread += std::fabs(v.X()) * tower.energy/max_energy;
      }

    return;
  }

  ClusterStat operator+(const ClusterStat& a) const
  {
    std::vector<TowerStat> my_towers = towers;
    my_towers.insert(
		     my_towers.end(),
		     std::make_move_iterator(a.towers.begin()),
		     std::make_move_iterator(a.towers.end()));
    struct ClusterStat stat;
    stat.towers = my_towers;
    stat.calculate();
    return stat;
  }

  ClusterStat& operator+=(const ClusterStat& a)
  {

    *this = *this + a;
    return *this;
  }
  
};

class EliminateBackground : public SubsysReco
{
 public:
  //! constructor
  EliminateBackground(const std::string& name = "EliminateBackground", const std::string& outfile = "testQA.root"); //int nevents = 100);

  //! destructor
  ~EliminateBackground() override;

  //! full initialization
  int Init(PHCompositeNode*) override;
  int InitRun(PHCompositeNode*) override;

  //! event processing method
  int process_event(PHCompositeNode*) override;

  //! end of run method
  int End(PHCompositeNode*) override;
  int get_cluster_key(unsigned int calokey);
  void add_to_cluster_map(TowerStat towerstat);
  
  int CheckEMCALStripe();
  int ClusterizeHCAL();
  void CollectEMCAL();
  void FillHistograms();
  void CombineInPhi();
  int PassCut();
  //  struct ClusterStat GetClusterStat(int cluskey);  
  void SetPassThrough(bool b) { passthru = b; }
  std::pair<float, float> GetRadii(TH2 *h2, TH2 *ht2);
  float FitLine(TH2 *h2);
 private:

  std::map<int, std::vector<TowerStat>> m_hcal_clusters;
  std::map<int, ClusterStat> m_hcal_clusters_stat;
  Fun4AllHistoManager *hm{nullptr};
  TowerInfoContainer* hcalout_towers{nullptr};
  TowerInfoContainer* emcal_towers{nullptr};
  TowerInfoContainer* emcal_retowers{nullptr};
  RawTowerGeomContainer *tower_geomOH{nullptr};
  RawTowerGeomContainer *tower_geomEM{nullptr};
  TrashInfo *trash_info;
  TH2F* h_hcalout{nullptr};
  TH2F* h_hcalout_time{nullptr};
  TH2F* h_r1_r2{nullptr};
  TH2F* h_r1_max_count{nullptr};
  TH2F* h_r1_max_total_count{nullptr};
  TH2F* h_emcal_max_count{nullptr};
  TH2F* h_emcal_max_total_count{nullptr};
  TH2F* h_emcal_eT_flat{nullptr};
  TH2F* h_emcal_eT_max_count{nullptr};
  TH2F* h_emcal_eT_max_total_count{nullptr};
  TH2F* h_emcal_eT_max_total_count_elip{nullptr};
  TH2F* h_chi2_elip{nullptr};
  TH2F* h_chi2_flat{nullptr};
  TH2F* h_chi2_r1{nullptr};
  TH2F* h_chi2_et{nullptr};
  TH2F* h_time_r1{nullptr};
  TH2F* h_time_elip{nullptr};
  TH2F *h_r1_r2_e{nullptr};// new TH2F("h_r1_r2_e","", 20, 0, 20, 20, 0, 20);
  TH2F *h_et_elip{nullptr};// new TH2F("h_et_elip","", 50, 0, 50, 40, 0, 40);
  TH2F *h_et_flat{nullptr};// new TH2F("h_et_flat","", 50, 0, 50, 40, -1, 1);
  TH2F *h_e_elip{nullptr};// new TH2F("h_e_elip","", 50, 0, 50, 40, 0, 40);
  TH2F *h_e_flat{nullptr};// new TH2F("h_e_flat","", 50, 0, 50, 40, -1, 1);
  TH2F *h_angle_flat{nullptr};// new TH2F("h_angle_flat","", 40, -1*TMath::Pi()/2, TMath::Pi()/2, 40, -1, 1);
  TH2F *h_angle_elip{nullptr};// new TH2F("h_angle_elip","", 40, -1*TMath::Pi()/2, TMath::Pi()/2, 40, 0, 40);
  TH2F *h_angle_flat_e{nullptr};// new TH2F("h_angle_flat_e","", 40, -1*TMath::Pi()/2, TMath::Pi()/2, 40, -1, 1);
  TH2F *h_angle_elip_e{nullptr};// new TH2F("h_angle_elip_e","", 40, -1*TMath::Pi()/2, TMath::Pi()/2, 40, 0, 40);
  TH2F *h_emcal_elip{nullptr};
  TH2F *h_emcal_r1{nullptr};
  TH2F *h_emcal_eT_elip{nullptr};
  TH2F *h_emcal_eT_r1{nullptr};

  TH2F *h_et_spread{nullptr};//Fill(m.second.energy, m.second.spread);
  TH2F *h_emcal_spread{nullptr};//Fill(m.second.emcal_energy, m.second.spread);
  TH2F *h_emcal_eT_spread{nullptr};//Fill(m.second.emcal_energy/m.second.energy, m.second.spread); 
  TH2F *h_r1_spread{nullptr};//Fill(m.second.r1, m.second.spread);

  TH2F *h_e_et{nullptr};// new TH2F("h_e_et","", 50, 0, 50, 50, 0, 50);
  TProfile *h_et_vertex{nullptr};// new TProfile("h_e_et","", 50, 0, 50, 50, 0, 50);



  int _range{1};
  std::string m_outfilename;

  float chi2{99};
  float min_time{10};
  int max_count{0};
  int max_total_count{0};
  int offset{0};
  float phi_cut{0.07};
  float energy_cut{0.5};
  float bkg_energy_cut{4.};
  float m_seed_energy_threshold{0.1};
  bool has_vertex{false};
  float emcal_r_cut{0.4};
  bool passthru{true};
  int r1_cut{4};
  int r1_cut_large{7};
  float spread_cut = 0.5;
};

#endif
