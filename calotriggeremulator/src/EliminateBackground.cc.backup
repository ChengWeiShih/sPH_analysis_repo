#include "EliminateBackground.h"
#include <calobase/RawTowerGeomContainer.h>
#include <calobase/RawTowerGeom.h>
// Calo 
#include "TMath.h"
#include <calobase/TowerInfo.h>
#include <calobase/TowerInfoDefs.h>
#include <fun4all/Fun4AllHistoManager.h>
#include <jetbackground/TowerBackground.h>
#include <phool/PHCompositeNode.h>
#include <phool/PHIODataNode.h>
#include <phool/PHNode.h>
#include <phool/PHNodeIterator.h>
#include <phool/PHObject.h>
#include <phool/getClass.h>
#include <phool/phool.h>

#include <calobase/TowerInfoContainer.h>

#include <fun4all/Fun4AllReturnCodes.h>

#include <phool/getClass.h>
#include <phool/phool.h>  // for PHWHERE
#include <jetbase/Jet.h>
#include <jetbase/JetContainer.h>
#include <jetbase/JetContainerv1.h>
#include <jetbase/Jetv2.h>
#include "TrashInfov1.h"
#include "TrashInfo.h"
#include <globalvertex/GlobalVertexMapv1.h>
#include <globalvertex/GlobalVertexv2.h>
#include <TF1.h>
#include <TVector2.h>
#include <TVector3.h>
#include <TH1.h>
#include <TH2.h>
#include <TProfile.h>
#include <TSystem.h>

#include <boost/format.hpp>

#include <cassert>
#include <cmath>  // for log10, pow, sqrt, abs, M_PI
#include <cstdint>
#include <iostream>  // for operator<<, endl, basic_...
#include <limits>
#include <map>  // for operator!=, _Rb_tree_con...
#include <string>
#include <utility>  // for pair

EliminateBackground::EliminateBackground(const std::string& name, const std::string& outfile)
  : SubsysReco(name),
    m_outfilename(outfile)

{						

}

EliminateBackground::~EliminateBackground()
{
  
}

int EliminateBackground::InitRun(PHCompositeNode* topNode)
{


  PHNodeIterator iter(topNode);
  PHCompositeNode *dstNode = dynamic_cast<PHCompositeNode *>(iter.findFirst("PHCompositeNode", "DST"));
  if (!dstNode)
  {
    std::cout << PHWHERE << "DST Node missing doing nothing" << std::endl;
  }

  PHNodeIterator dstIter(dstNode);

  PHCompositeNode *detNode = dynamic_cast<PHCompositeNode *>(dstIter.findFirst("PHCompositeNode", "GLOBAL"));
  if (!detNode)
  {
    std::cout << PHWHERE << "Detector Node missing, making one" << std::endl;
    detNode = new PHCompositeNode("GLOBAL");
    dstNode->addNode(detNode);
  }

  TrashInfo *mb = new TrashInfov1();

  PHIODataNode<PHObject> *mbNode = new PHIODataNode<PHObject>(mb, "TrashInfo", "PHObject");
  detNode->addNode(mbNode);

  return 0;

}
int EliminateBackground::Init(PHCompositeNode* /*unused*/)
{

  std::cout << "Leaving EliminateBackground::Init" << std::endl;
  hm = new Fun4AllHistoManager("EliminateBackgroundHistos");
  h_hcalout = new TH2F("HCALOUT","", 24, -0.5, 23.5, 64, -0.5, 63.5);
  h_hcalout_time = new TH2F("HCALOUT_TIME","", 24, -0.5, 23.5, 64, -0.5, 63.5);
  h_r1_r2 = new TH2F("h_r1_r2","", 20, 0, 20, 20, 0, 20);
  h_r1_r2_e = new TH2F("h_r1_r2_e","", 20, 0, 20, 20, 0, 20);
  h_et_elip = new TH2F("h_et_elip","", 50, 0, 50, 40, 0, 40);
  h_emcal_elip = new TH2F("h_emcal_elip","", 520, 0, 50, 40, 0, 40);
  h_emcal_eT_elip = new TH2F("h_emcal_eT_elip","", 400, -2, 2, 240, 0, 24);
  h_et_flat = new TH2F("h_et_flat","", 50, 0, 50, 210, -20, 1);
  h_e_elip = new TH2F("h_e_elip","", 50, 0, 50, 40, 0, 40);
  h_e_flat = new TH2F("h_e_flat","", 50, 0, 50, 40, -1, 1);
  h_angle_flat = new TH2F("h_angle_flat","", 40, -1*TMath::Pi()/2, TMath::Pi()/2, 40, -1, 1);
  h_angle_elip = new TH2F("h_angle_elip","", 40, -1*TMath::Pi()/2, TMath::Pi()/2, 40, 0, 40);
  h_angle_flat_e = new TH2F("h_angle_flat_e","", 40, -1*TMath::Pi()/2, TMath::Pi()/2, 40, -1, 1);
  h_angle_elip_e = new TH2F("h_angle_elip_e","", 40, -1*TMath::Pi()/2, TMath::Pi()/2, 40, 0, 40);
  h_emcal_r1 = new TH2F("h_emcal_r1","", 500, 0, 50, 24, 0, 24);
  h_emcal_eT_r1 = new TH2F("h_emcal_eT_r1","", 200 , -2, 2, 24, 0, 24);
  h_chi2_elip = new TH2F("h_chi2_elip","", 200, 0, 2, 40, 0, 40);
  h_chi2_flat = new TH2F("h_chi2_flat","", 200, 0, 2, 40, -1, 1);
  //TH2F* h_r1_max_count{nullptr};
  //TH2F* h_emcal_max_count{nullptr};
  //TH2F* h_emcal_eT_max_count{nullptr};
  h_r1_max_count = new TH2F("h_r1_max_count","", 24, 0, 24, 24, 0, 24);
  h_r1_max_total_count = new TH2F("h_r1_max_total_count","", 24, 0, 24, 24, 0, 24);
  h_emcal_max_count = new TH2F("h_emcal_max_count","", 600, -10, 50, 24, 0, 24);
  h_emcal_max_total_count = new TH2F("h_emcal_max_total_count","", 600, -10, 50, 24, 0, 24);
  h_emcal_eT_max_count = new TH2F("h_emcal_eT_max_count","", 200, -2, 2, 24, 0, 24);
  h_emcal_eT_flat = new TH2F("h_emcal_eT_flat","", 200, -2, 2, 210, -20, 1);
  h_emcal_eT_max_total_count = new TH2F("h_emcal_eT_max_total_count","", 200, -2, 2, 24, 0, 24);
  h_emcal_eT_max_total_count_elip = new TH2F("h_emcal_eT_max_total_count_elip","", 200, -2, 2, 24, 0, 24);
  h_chi2_r1 = new TH2F("h_chi2_r1","", 200, 0, 2, 24, 0, 24);
  h_chi2_et = new TH2F("h_chi2_et","", 200, 0, 2, 50, 0, 50);

  h_time_elip = new TH2F("h_time_elip","", 400, -4, 4, 40, 0, 40);
  h_time_r1 = new TH2F("h_time_r1","", 400, -4, 4, 24, 0, 24);
  h_e_et = new TH2F("h_e_et","", 50, 0, 50, 50, 0, 50);
  h_et_vertex = new TProfile("h_et_vertex","", 50, 0, 50);

  h_emcal_eT_spread = new TH2F("h_emcal_eT_spread","", 200, -2, 2, 500, 0, 50);
  h_et_spread = new TH2F("h_eT_spread","", 50, 0, 50, 500, 0, 50);
  h_emcal_spread = new TH2F("h_emcal_spread","", 600, -10, 50, 500, 0, 50);
  h_r1_spread = new TH2F("h_r1_spread","", 24, 0, 24, 500, 0, 50);
      // h_et_spread->Fill(m.second.energy, m.second.spread);
      // h_emcal_spread->Fill(m.second.emcal_energy, m.second.spread);
      // h_emcal_et_spread->Fill(m.second.emcal_energy/m.second.energy, m.second.spread);

      // h_et_spread->Fill(m.second.r1, m.second.spread);
  hm->registerHisto(h_emcal_eT_flat);
  hm->registerHisto(h_emcal_eT_spread);
  hm->registerHisto(h_et_spread);
  hm->registerHisto(h_emcal_spread);
  hm->registerHisto(h_r1_spread);
  hm->registerHisto(h_e_et);
  hm->registerHisto(h_r1_r2);
  hm->registerHisto(h_angle_elip);
  hm->registerHisto(h_et_elip);
  hm->registerHisto(h_e_elip);
  hm->registerHisto(h_angle_flat);
  hm->registerHisto(h_et_flat);
  hm->registerHisto(h_e_flat);
  hm->registerHisto(h_et_vertex);
  hm->registerHisto(h_chi2_et);
  hm->registerHisto(h_chi2_flat);
  hm->registerHisto(h_chi2_elip);
  hm->registerHisto(h_chi2_r1);
  hm->registerHisto(h_time_r1);
  hm->registerHisto(h_time_elip);
  hm->registerHisto(h_emcal_elip);
  hm->registerHisto(h_emcal_r1);
  hm->registerHisto(h_emcal_eT_elip);
  hm->registerHisto(h_emcal_eT_r1);
  hm->registerHisto(h_emcal_max_count);
  hm->registerHisto(h_emcal_max_total_count);
  hm->registerHisto(h_emcal_eT_max_count);
  hm->registerHisto(h_emcal_eT_max_total_count);
  hm->registerHisto(h_emcal_eT_max_total_count_elip);
  hm->registerHisto(h_r1_max_count);
  hm->registerHisto(h_r1_max_total_count);
  return Fun4AllReturnCodes::EVENT_OK;
}

int EliminateBackground::process_event(PHCompositeNode* topNode)
{

  trash_info = findNode::getClass<TrashInfo>(topNode, "TrashInfo");
  
  if (!trash_info)
  {
    std::cout << "no trash bias node " << std::endl;
    return Fun4AllReturnCodes::ABORTRUN;
  }


  hcalout_towers = findNode::getClass<TowerInfoContainer>(topNode, "TOWERINFO_CALIB_HCALOUT");

  tower_geomOH = findNode::getClass<RawTowerGeomContainer>(topNode, "TOWERGEOM_HCALOUT");
  
  emcal_towers = findNode::getClass<TowerInfoContainer>(topNode, "TOWERINFO_CALIB_CEMC");
  emcal_retowers = findNode::getClass<TowerInfoContainer>(topNode, "TOWERINFO_CALIB_CEMC_RETOWER");
  
  tower_geomEM = findNode::getClass<RawTowerGeomContainer>(topNode, "TOWERGEOM_CEMC");

  GlobalVertexMap *vertexmap = findNode::getClass<GlobalVertexMap>(topNode, "RealVertexMap");
  has_vertex = false;
  if (vertexmap)
    {
      if (!vertexmap->empty())
	{
	  GlobalVertex *vtx = vertexmap->begin()->second;
	  if (vtx)
	    {
	      if (fabs(vtx->get_z()) < 100)
		{
		  has_vertex = true;
		}
	    }
	}
    }



  //JetContainer *jets_r1 = findNode::getClass<JetContainer>(topNode, "AntiKt_TowerInfo_OHCal_r1");

  // if (!jets_r1)
  //   {
  //     std::cout << " need jets " << std::endl;
  //     return Fun4AllReturnCodes::ABORTRUN;
  //   }

  if (CheckEMCALStripe())
    {
      return Fun4AllReturnCodes::EVENT_OK;
    }

  if (ClusterizeHCAL())
    {
      return Fun4AllReturnCodes::EVENT_OK;
    }

  CombineInPhi();
  
  CollectEMCAL();

  FillHistograms();

  if (passthru) return Fun4AllReturnCodes::EVENT_OK;

  return PassCut();
  // for (auto jet : *jets_r1)
  //   {
  //     h_hcalout->Reset();      
  //     h_hcalout_time->Reset();      
  //     float jet_phi = jet->get_phi();
  //     int jet_i_phi = jet_phi/(TMath::Pi()/32.);
  //     if (jet_i_phi < 0) jet_i_phi += 64;
  //     offset = 32 - jet_i_phi;
  //     float total_jet_eT = 0;
  //     for (auto comp : jet->get_comp_vec())
  // 	{
  // 	  unsigned int channel = comp.second;
  // 	  TowerInfo *tower;
	  
  // 	  float tower_eT = 0;

  // 	  if (!(comp.first == 27)) continue;
	  
  // 	  tower = hcalout_towers->get_tower_at_channel(channel);
	  
  // 	  if (!tower || !tower_geomOH)
  // 	    {
  // 	      continue;
  // 	    }
	  
  // 	  unsigned int calokey = hcalout_towers->encode_key(channel);
  // 	  int ieta = hcalout_towers->getTowerEtaBin(calokey);
  // 	  int iphi = hcalout_towers->getTowerPhiBin(calokey);
  // 	  const RawTowerDefs::keytype key = RawTowerDefs::encode_towerid(RawTowerDefs::CalorimeterId::HCALOUT, ieta, iphi);
  // 	  float tower_eta = tower_geomOH->get_tower_geometry(key)->get_eta();
  // 	  tower_eT = tower->get_energy() / std::cosh(tower_eta);
  // 	  total_jet_eT += tower_eT;
  // 	  float tower_time = tower->get_time();
  // 	  if (tower_eT > 0.05)
  // 	    {
  // 	      int bin_phi = iphi + offset;
  // 	      if(bin_phi > 63) bin_phi = bin_phi-64;
  // 	      if(bin_phi < 0) bin_phi = bin_phi+64;
  // 	      h_hcalout->Fill(ieta, bin_phi, tower_eT);
  // 	      h_hcalout_time->Fill(ieta, bin_phi, tower_time);
  // 	    }

  // 	}
      
  //     if (total_jet_eT < 2) continue;
  //     float emcal_tower_eT = 0.0;
  //     auto emcal_tower_geometries = tower_geomEM->get_tower_geometries();
  //     TVector2 jet_loc(jet->get_eta(), jet->get_phi());
  //     for (auto iter_emcal = emcal_tower_geometries.first; iter_emcal != emcal_tower_geometries.second; ++iter_emcal)
  // 	{
  // 	  TVector2 em_tower(iter_emcal->second->get_eta(), iter_emcal->second->get_phi());
  // 	  TVector2 diff = em_tower - jet_loc;
  // 	  if (fabs(diff.Y()) > TMath::Pi()) diff.SetY( diff.Y() + (diff.Y() > 0 ? -1 : 1)*TMath::Pi());

  // 	  if (sqrt(diff*diff) > 1.0) continue;
	  
  // 	  int ieta = iter_emcal->second->get_bineta();
  // 	  int iphi = iter_emcal->second->get_binphi();
  // 	  unsigned int key = TowerInfoDefs::encode_emcal(ieta, iphi);
  // 	  emcal_tower_eT += emcal_towers->get_tower_at_key(key)->get_energy();///std::cosh(iter_emcal->second->get_eta());
  // 	}
      
  //     if (h_hcalout->GetEntries() > 1)
  //     	{


  //     	  float theta = FitLine(h_hcalout);	  
  //     	  std::pair<float, float> r1r2 = GetRadii(h_hcalout, h_hcalout_time);
  //     	  float elip = r1r2.first/r1r2.second;
  //     	  float flattening = (r1r2.first - r1r2.second)/r1r2.first;
  //     	  h_angle_flat->Fill(theta, flattening);
  //     	  h_angle_elip->Fill(theta, elip);
  //     	  h_emcal_elip->Fill(emcal_tower_eT, elip);
  //     	  h_emcal_eT_elip->Fill(emcal_tower_eT/total_jet_eT, elip);
  // 	  h_et_elip->Fill(total_jet_eT, elip);
  //     	  h_et_flat->Fill(total_jet_eT, flattening);
  //     	  h_emcal_r1->Fill(emcal_tower_eT, r1r2.first);
  //     	  h_emcal_eT_r1->Fill(emcal_tower_eT/total_jet_eT, r1r2.first);
  //     	  h_r1_r2->Fill(r1r2.first, r1r2.second);
  //     	  h_et_vertex->Fill(total_jet_eT, (has_vertex? 1: 0));
  // 	  h_emcal_eT_max_count->Fill(emcal_tower_eT/total_jet_eT, max_count);
  // 	  h_emcal_max_count->Fill(emcal_tower_eT, max_count);
  // 	  h_r1_max_count->Fill(r1r2.first, max_count);

  // 	  h_emcal_eT_max_total_count->Fill(emcal_tower_eT/total_jet_eT, max_total_count);
  // 	  h_emcal_eT_max_total_count_elip->Fill(emcal_tower_eT/total_jet_eT, static_cast<float>(max_total_count)/r1r2.second);
  // 	  h_emcal_max_total_count->Fill(emcal_tower_eT, max_total_count);
  // 	  h_r1_max_total_count->Fill(r1r2.first, max_total_count);

  // 	  h_time_r1->Fill(min_time, r1r2.first);
  // 	  h_time_elip->Fill(min_time, elip);
  // 	  if (r1r2.first > 2)
  // 	    {
  // 	      h_chi2_et->Fill(chi2, total_jet_eT);
  // 	      h_chi2_elip->Fill(chi2, elip);
  // 	      h_chi2_flat->Fill(chi2, flattening);
  // 	      h_chi2_r1->Fill(chi2, r1r2.first);
  // 	    }

  // 	}
  //     break;
  //   }

  return Fun4AllReturnCodes::EVENT_OK;; 
  
  
}
int EliminateBackground::PassCut()
{

  bool pass = false;
  
  for (auto &m : m_hcal_clusters_stat)
    {

      // Above Energy Cut
      if (m.second.energy < bkg_energy_cut) continue;

      //      if (m.second.max_energy > 3) continue;
      // r1 >= 4
      if (m.second.r1 < r1_cut) continue;

      if (m.second.spread < spread_cut) 
	{
	  if (m.second.r1 < r1_cut_large) continue;
	}
      
      pass = true;

      trash_info->setIsTrash(pass);
      trash_info->setR1(m.second.r1);
      trash_info->setSpread(m.second.spread);
      trash_info->setEnergy(m.second.energy);
      trash_info->setEMCALEnergy(m.second.emcal_energy);
      trash_info->setEMCALorHCAL(1);
    }
  



  return Fun4AllReturnCodes::EVENT_OK;
}

void EliminateBackground::FillHistograms()
{
  // std::cout << "FillingHistograms()" << std::endl;
  struct ClusterStat maxstat = m_hcal_clusters_stat.begin()->second;
  for (auto &m : m_hcal_clusters_stat)
    {
      if (m.second.r1 > maxstat.r1)
	{
	  maxstat = m.second;
	}
      else if (m.second.r1 == maxstat.r1 && m.second.energy > maxstat.energy)
	{
	  maxstat = m.second;
	}
    }

  trash_info->setIsTrash(false);
  trash_info->setEMCALorHCAL(1);
  trash_info->setR1(maxstat.r1);
  trash_info->setSpread(maxstat.spread);
  trash_info->setEnergy(maxstat.energy);
  trash_info->setEMCALEnergy(maxstat.emcal_energy);

  //  maxstat.print();
  if (maxstat.energy < bkg_energy_cut) return;


  float elip = maxstat.r1/maxstat.r2;
  float flattening = (maxstat.r1 - maxstat.r2)/maxstat.r1;
      
  h_emcal_elip->Fill(maxstat.emcal_energy, elip);
  h_emcal_eT_elip->Fill(maxstat.emcal_energy/maxstat.energy, elip);
  h_emcal_eT_flat->Fill(maxstat.emcal_energy/maxstat.energy, flattening);
  h_et_elip->Fill(maxstat.energy, elip);
  h_et_flat->Fill(maxstat.energy, flattening);
  h_emcal_r1->Fill(maxstat.emcal_energy, maxstat.r1);
  h_emcal_eT_r1->Fill(maxstat.emcal_energy/maxstat.energy, maxstat.r1);
  h_r1_r2->Fill(maxstat.r1, maxstat.r2);
  h_et_vertex->Fill(maxstat.energy, (has_vertex? 1: 0));

  h_et_spread->Fill(maxstat.energy, maxstat.spread);
  h_emcal_spread->Fill(maxstat.emcal_energy, maxstat.spread);
  h_emcal_eT_spread->Fill(maxstat.emcal_energy/maxstat.energy, maxstat.spread);

  h_r1_spread->Fill(maxstat.r1, maxstat.spread);

  // h_emcal_eT_max_count->Fill(m.second.emcal_energy/m.second.energy, max_count);
  // h_emcal_max_count->Fill(m.second.emcal_energy, max_count);
  // h_r1_max_count->Fill(m.second.r1, max_count);
  // h_emcal_eT_max_total_count->Fill(m.second.emcal_energy/m.second.energy, max_total_count);
  // h_emcal_eT_max_total_count_elip->Fill(m.second.emcal_energy/m.second.energy, static_cast<float>(max_total_count)/m.second.r2);
  // h_emcal_max_total_count->Fill(m.second.emcal_energy, max_total_count);
  // h_r1_max_total_count->Fill(m.second.r1, max_total_count);
    
  return;
}

int EliminateBackground::get_cluster_key(unsigned int calokey)
{

  for ( auto hcal_iter = m_hcal_clusters.begin(); hcal_iter != m_hcal_clusters.end(); ++hcal_iter)
    {

      if (std::find_if(hcal_iter->second.begin(), hcal_iter->second.end(), [calokey] (auto a) { return a.key == calokey; } ) == hcal_iter->second.end()) continue;
      
      return hcal_iter->first;
      
    }
  return -1;
}
void EliminateBackground::add_to_cluster_map(TowerStat towerstat)
{
  // check each direction
  int this_eta = towerstat.eta;
  int this_phi = towerstat.phi;

  std::vector<int> adj_clusters;
  for (int ieta  = this_eta - 1 ; ieta <= this_eta + 1; ieta++)
    {
      if (ieta < 0 || ieta > 23) continue;
      for (int iphi  = this_phi - 1 ; iphi <= this_phi + 1; iphi++)
	{
	  int iiphi = iphi;
	  if (iiphi < 0) iiphi += 64;
	  if (iiphi > 63) iiphi -= 64;

	  unsigned int next_key = TowerInfoDefs::encode_hcal(ieta, iiphi);
	  int cluskey = get_cluster_key(next_key);

	  if (cluskey == -1) continue;
	  adj_clusters.push_back(cluskey);
	}
    }

  if (adj_clusters.size() == 0)
    {
      int size  = m_hcal_clusters.size();
      m_hcal_clusters[size] = std::vector<TowerStat>{towerstat};
      return;
    }
  std::sort(adj_clusters.begin(), adj_clusters.end());
  
  auto ip = std::unique(adj_clusters.begin(), adj_clusters.end());
  
  adj_clusters.resize(std::distance(adj_clusters.begin(),ip));

  while( adj_clusters.size() > 1)
    {
      int frontkey = adj_clusters.front();
      auto key_iter = adj_clusters.end() - 1;
      int backkey = *key_iter;

      m_hcal_clusters[frontkey].insert(
			 m_hcal_clusters[frontkey].end(),
			 std::make_move_iterator(m_hcal_clusters[backkey].begin()),
			 std::make_move_iterator(m_hcal_clusters[backkey].end()));

      auto erase_cluster = m_hcal_clusters.find(backkey);
      if (erase_cluster != m_hcal_clusters.end()) m_hcal_clusters.erase(erase_cluster);
      

      adj_clusters.erase(key_iter);
    }

  m_hcal_clusters[adj_clusters.front()].push_back(towerstat);
  
  return;
}

void EliminateBackground::CollectEMCAL()
{
  auto emcal_tower_geometries = tower_geomEM->get_tower_geometries();
  for (auto iter_emcal = emcal_tower_geometries.first; iter_emcal != emcal_tower_geometries.second; ++iter_emcal)
    {
      TVector2 em_tower(iter_emcal->second->get_eta(), iter_emcal->second->get_phi());
      int ieta = iter_emcal->second->get_bineta();
      int iphi = iter_emcal->second->get_binphi();
      unsigned int key = TowerInfoDefs::encode_emcal(ieta, iphi);

      for (auto &m : m_hcal_clusters_stat)
	{	  
	  TVector2 clus_loc(m.second.eta, m.second.phi);
	  TVector2 diff = em_tower - clus_loc;
  	  if (fabs(diff.Y()) > TMath::Pi()) diff.SetY( diff.Y() + (diff.Y() > 0 ? -1 : 1)*TMath::Pi());

  	  if (sqrt(diff*diff) > emcal_r_cut) continue;
	  
  	  m.second.emcal_energy += emcal_towers->get_tower_at_key(key)->get_energy()/std::cosh(iter_emcal->second->get_eta());
  	}
    }      

}

int EliminateBackground::CheckEMCALStripe()
{

  int count = 0;
  float energy = 0;
  for (int ieta = 0; ieta < 24; ieta++)
    {
      energy = 0;
      count  = 0;
      for (int iphi = 0; iphi < 64; iphi++)
	{
	  unsigned int calokey = TowerInfoDefs::encode_hcal(ieta, iphi);
	  TowerInfo *tower = emcal_retowers->get_tower_at_key(calokey);

	  const RawTowerDefs::keytype key = RawTowerDefs::encode_towerid(RawTowerDefs::CalorimeterId::HCALOUT, ieta, iphi);
	  float tower_eta = tower_geomOH->get_tower_geometry(key)->get_eta();
	  float tower_eT = tower->get_energy() / std::cosh(tower_eta);
	  if (tower_eT < 0.5) 
	    {
	      break;
	    }
	  energy += tower_eT;
	  count++;
	}
      if (count == 64)
	break;
    }
  // std::cout << " looking ... " <<std::endl;
  if (count < 64) return 0;

  trash_info->setIsTrash(true);
  trash_info->setR1(count);
  trash_info->setSpread(1);
  trash_info->setEnergy(energy);
  trash_info->setEMCALEnergy(energy);
  trash_info->setEMCALorHCAL(0);

  // std::cout << "FOUND EMCAL STRIPE" <<std::endl;
  return 1;
  
}
int EliminateBackground::ClusterizeHCAL()
{
  //  std::unordered_map<int, HCAL_Cluster> m_hcal_clusters;
  m_hcal_clusters.clear();
  m_hcal_clusters_stat.clear();

  int n_hcal_towers = hcalout_towers->size();
  for (int itower = 0; itower < n_hcal_towers; itower++)
    {
      // check for seeds
      TowerInfo *tower = hcalout_towers->get_tower_at_channel(itower);

      // tower must exist
      if (!tower) continue;

      unsigned int calokey = hcalout_towers->encode_key(itower);
      int ieta = hcalout_towers->getTowerEtaBin(calokey);
      int iphi = hcalout_towers->getTowerPhiBin(calokey);
      const RawTowerDefs::keytype key = RawTowerDefs::encode_towerid(RawTowerDefs::CalorimeterId::HCALOUT, ieta, iphi);
      float tower_eta = tower_geomOH->get_tower_geometry(key)->get_eta();
      float tower_phi = tower_geomOH->get_tower_geometry(key)->get_phi();

      float tower_eT = tower->get_energy() / std::cosh(tower_eta);
      // tower transverse energy must be greater than seed.


      if (tower_eT < m_seed_energy_threshold) continue;

      TowerStat ts;
      ts.key = calokey;
      ts.energy = tower_eT;
      ts.eta = tower_eta;
      ts.phi = tower_phi;
      ts.ieta = ieta;
      ts.iphi = iphi;

      add_to_cluster_map(ts);

    }
  for (auto &m : m_hcal_clusters)
    {
      struct ClusterStat cs(m.second);
      m_hcal_clusters_stat[m.first] = cs;
    }
  if (m_hcal_clusters_stat.size() > 0)
    {
      return 0;
    }
  return 1;
}

void EliminateBackground::CombineInPhi()
{
  // Combine clusters in phi

  std::vector<std::pair<unsigned int, unsigned int>> combos{};
  std::map<int, ClusterStat>::iterator n;
  for (auto m = m_hcal_clusters_stat.begin(); m != m_hcal_clusters_stat.end(); ++m)
    {
      if (m->second.energy < energy_cut || m->second.r1 > 2) continue;
      n = m_hcal_clusters_stat.begin();
      while (n != m_hcal_clusters_stat.end())
	{
	  if (n == m)
	    {
	      n++;
	      continue;
	    }

	  if (n->second.energy < energy_cut || n->second.r2 > 2) 
	    { 
	      n++;
	      continue;
	    }
	  float dphi = m->second.phi - n->second.phi;
	  if (dphi > TMath::Pi()) dphi -= 2*TMath::Pi();
	  if (dphi < -1*TMath::Pi()) dphi += 2*TMath::Pi();
	  
	  if (fabs(dphi) < phi_cut)
	    {
	      combos.push_back(std::make_pair(m->first, n->first));
	    }
	  n++;
	}
    }
  
  for (auto &m : combos)
    {
      if (m_hcal_clusters_stat.find(m.first) == m_hcal_clusters_stat.end()) continue;

      auto erase_cluster = m_hcal_clusters_stat.find(m.second);

      if (erase_cluster == m_hcal_clusters_stat.end()) continue;

      m_hcal_clusters_stat[m.first] += m_hcal_clusters_stat[m.second];

      m_hcal_clusters_stat.erase(erase_cluster);
      
    }

}

std::pair<float, float> EliminateBackground::GetRadii(TH2* h2, TH2* ht2)
{
  // Maximum Bin cluster;
  
  int l = h2->GetMaximumBin();
  int binx, biny, binz;
  // get maximum bin in terms of a x and y.

  int lx, ly;
  h2->GetBinXYZ(l, lx, ly, binz);
  // Find all consecuative towers with energy above 500 MeV

  std::vector<std::pair<int, unsigned int>> cluster;


  // look to see it
  std::vector<int> unique_ybin;
  std::vector<int> unique_xbin;
  std::vector<float> energy_line;

  cluster.push_back(std::make_pair(l, 0));
  unique_xbin.push_back(lx);
  unique_ybin.push_back(ly);
  float sum = 0.0;
  min_time = 10;

  int count1 = 0;
  while ( count1++ < 24)
    {

      auto p = std::find_if(cluster.begin(), cluster.end(), [] (auto iclus) { return ( (iclus.second & 0xf) != 0xf); });

      if (p == cluster.end()) break;

      h2->GetBinXYZ(p->first, binx, biny, binz);

      for (unsigned int i = 0 ; i < 4; i++)
	{

	  if (( p->second >> i ) & 0x1U) 
	    { 
	      continue;
	    }


	  p->second = (p->second | (0x1U << i)) & 0xfU;
	  int ibinx = binx + ((i)%2)*(((i)/2)*2-1);
	  if (ibinx < 1 || ibinx > 24) 
	    { 
	      continue;
	    }


	  int ibiny = biny + ((i+1)%2)*(((i)/2)*2-1);
	  if (ibiny < 1) ibiny = 64;
	  if (ibiny > 64) ibiny = 1;
	  
	  int gbin = h2->GetBin(ibinx, ibiny);

	  if ( h2->GetBinContent(gbin) < 0.05 )
	    {
	      continue;
	    }

	  if ( std::find_if(cluster.begin(), cluster.end(), [gbin] (auto j) { return j.first == gbin ; } ) == cluster.end())
	    {
	      int shift = i - (i/2)*4 + 2;
	      cluster.push_back(std::make_pair(gbin, 0x1U << shift));
	      if (std::find(unique_xbin.begin(), unique_xbin.end(), ibinx) == unique_xbin.end()) unique_xbin.push_back(ibinx);
	      if (std::find(unique_ybin.begin(), unique_ybin.end(), ibiny) == unique_ybin.end()) unique_ybin.push_back(ibiny);
	      if (biny == ly)
		{
		  sum += h2->GetBinContent(gbin);
		  energy_line.push_back(h2->GetBinContent(gbin));
		  
		  if (ht2->GetBinContent(gbin) < min_time)
		    {
		      min_time = ht2->GetBinContent(gbin);
		    }
		}    

	      break;
	    }
	}
      
    }

  max_count = 0;
  std::sort(unique_ybin.begin(), unique_ybin.end(), [] (auto a, auto b) { return a < b; });
  int bin_low = unique_ybin.front();
  int bin_high = unique_ybin.back();
  for (int ibin = bin_low - 1; ibin <= bin_high + 1; ibin ++)
    {

      int iphi = (ibin - 1) - offset;
      
      if (iphi < 0) iphi += 64;
      if (iphi > 63) iphi -= 64;
      
      int count = 0;
      for (int ieta = 0; ieta < 24; ieta++)
	{
	  int check_global_bin = h2->GetBin(ieta+1, ibin);
	  if (std::find_if(cluster.begin(), cluster.end(), [check_global_bin] (auto a) { return a.first == check_global_bin; }) != cluster.end()) continue;
	  unsigned int key = TowerInfoDefs::encode_hcal(ieta, iphi);
	  if (hcalout_towers->get_tower_at_key(key)->get_energy() < 0.05)
	    continue;
	      count++;
	}

      if (count > max_count) max_count = count;	  
    }
  // now we have the y_bin min and 



  sum /= static_cast<float>(energy_line.size());
  chi2 = 0.0;
  for (auto &energy : energy_line)
    {
      chi2 += (energy - sum)*(energy - sum)/sum;
    }
  chi2 /= static_cast<float>(energy_line.size());

  float r1 = unique_xbin.size();

  float r2 = unique_ybin.size();
  max_total_count = max_count + r1;
  cluster.clear(); 
  return std::make_pair(r1, r2);
  // TH1D *h_x = (TH1D*) h2->ProjectionX();
  // TH1D *h_y = (TH1D*) h2->ProjectionY();

  // float x_w = h_x->GetStdDev();
  // if (x_w == 0) x_w = 0.5;

  // // hy->Fit("fg");


  // float y_w = h_y->GetStdDev();
  // if (y_w == 0) y_w = 0.5;

  // 
}

float EliminateBackground::FitLine(TH2* h2)
{
  TF1 *l = new TF1("line","[0] + [1]*x", 2);
  l->SetParameters(32, 0);

  h2->Fit("line", "NDORQ");
  return TMath::ATan(l->Eval(1) - l->Eval(0));
}

int EliminateBackground::End(PHCompositeNode* /*unused*/) 
{
  hm->dumpHistos(m_outfilename.c_str());
  return Fun4AllReturnCodes::EVENT_OK;
}
